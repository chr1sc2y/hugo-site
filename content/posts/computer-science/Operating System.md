---
title: "操作系统"
date: 2015-07-05T08:57:52+10:00
draft: true
categories: ["Computer Science"]
---

# 操作系统

## 内核

### 1. 用户态切换到内核态的方式

1. 系统调用
    - 用户进程主动发起，将参数传给内核，内核态运行的时候要保存用户进程的一些寄存器值和变量等（进程上下文）
2. 异常 / 设备中断（被动）

### 2. 为什么要用户态和内核态

1. 防止用户直接执行比较危险的指令造成系统崩溃
2. 处理器总处于以下状态中的一种
    1. 内核态，运行于进程上下文，内核代表进程运行于内核空间
    2. 内核态，运行于中断上下文，内核代表硬件运行于内核空间
    3. 用户态，运行于用户空间

### 系统调用

- 计算机系统的各种资源是有限的，有很多进程都需要访问这些资源，为了更好的管理这些资源，进程是不允许直接对他们进行操作的，所有对这些资源的访问都必须由操作系统控制；也就是说操作系统是使用这些资源的唯一入口，操作这些资源的方法叫做系统调用 System Call
- 从用户态切换到内核态的方法是中断；中断是一个硬件或软件请求，要求 CPU 暂停当前的工作，去处理更重要的事情；中断是依靠软件实现的
- Linux 中，内核会维护一张系统调用表 sys_call_table，每个系统调用都有相应的系统调用号作为唯一的标识，表中的元素是系统调用函数的起始地址，而系统调用号就是系统调用在调用表中的偏移量

## 进程和线程

### 进程

- 进程是资源分配的基本单位
- 进程是对程序的一个抽象，包括程序计数器、寄存器和变量的当前值
- 进程控制块 Process Control Block 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作
- 创建或销毁进程时，系统要为其分配或回收资源，如内存空间，I/O 设备等，其所付出的开销远大于创建或撤销线程时的开销
- 进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，开销较大
- 进程通信需要借助 IPC

#### 进程间通信 Inter Process Communication

- 进程间通信指多个进程间进行数据传输或同步的方法
- 进程间通信的目的是资源共享，通知事件，进程控制等

1. 匿名管道 Pipeline
    - 管道只能在具有公共祖先的两个进程之间使用
    - 管道是由内核管理的一个缓冲区，其两端分别连接两个进程，一个进程会向管道输入信息，另一个进程会向管道读取信息
    - 管道只支持半双工通信，数据只能向一个方向流动；当双方需要进行通信时，需要建立两个管道
    - 当管道中没有信息时，读取信息的进程会等待，直到有信息被输入进管道；当管道中信息装满的时候，输入信息的进程会等待，直到有信息被读取出管道；当两个进程都被终结时，管道也会被终结
    - 输入管道的消息会被添加在管道缓冲区的末尾，而读取管道的信息只能从缓冲区的头部读出；如果管道缓冲区头部的数据一直未被读出，那么写操作将被阻塞

2. 命名管道 Named Pipeline / FIFO
    - 命名管道可以在任意两个进程之间使用
    - FIFO 是一种特殊类型的文件，写进程向 FIFO 文件中进行写入，读进程从 FIFO 文件中进行读取；删除 FIFO 文件时，管道也随之消失
    - 可以通过 FIFO 文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接

3. 消息队列 Message Queue

    - 消息队列是一个链表，而消息就是带有特定格式和优先级的记录节点
    - 对消息队列有写权限的进程可以根据一定的规则在消息链表中添加消息，对消息队列有读权限的进程则可以从消息队列中获得所需的信息
    - 消息队列随内核一直持续存在
    - 优点：
        1. 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难
        2. 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法
        3. 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收

4. 共享内存 Shared Memory

    - 共享内存是可以被不同中央处理器访问的大容量内存，其允许多个进程访问同一块内存；如果一个进程向共享的内存区域写入了数据，那么共享这个内存区域的所有进程都可以访问其中的内容
    - 共享内存是 Unix 下默认的进程间通信方法，常用于一个程序的多个进程间通信
    - 优点：进程直接读写内存，不进行数据拷贝，效率高
    - 缺点：没有同步机制保证多个进程对同一块内存区域的读写是互斥的，需要手动解决

5. 信号 Signal
    - 系统通过信号来通知进程系统中发生的事件
    - 用于进程间通信以及发送信号给进程本身

6. 信号量 Semaphore
    - 信号量是一个计数器，用于协调多个进程对共享数据的访问
    - 对信号量的所有操作都是原子操作，有等待 P(sv) 和 发送 V(sv) 两种操作
    - 最简单的信号量是互斥信号量，其值只能取 0 或 1；进行等待操作时，会测试这个信号量的值，如果其值等于 1，就会减 1；如果其值为 0，就挂起该进程的执行；而进行发送操作时，会将该信号量的值加 1
    - 例如两个进程共享初始值为 1 的互斥信号量 sv，其中一个进程执行了 P(sv) 操作，它将获得信号量并获取共享资源，并使 sv 减 1，这时第二个进程也执行了 P（sv）操作，因为此时 sv 的值为 0，它将被阻止获取共享资源，并被挂起并等待前一个进程放弃共享资源并执行 V(sv) 操作释放信号量后，才能获得信号量并获取共享资源

7. 套接字 Socket
    - 不同计算机上的进程可以通过 Socket 网络编程进行进程间通信

#### 进程调度算法

- 不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法

1. 批处理系统
    - 批处理系统没有太多的用户操作，因此该系统中的调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）

    1.1 先到先服务 First-Come First-Served FCFS
    - 非抢占式，按照请求的顺序进行调度
    - 有利于长作业

    1.2 短作业优先 Shortest Job First SJF
    - 非抢占式，按照估计运行时间最短的顺序进行调度
    - 长作业可能会饿死，处于一直等待的状态

    1.3 最短剩余时间优先 Shortest Remaining Time Next SRTN
    - 抢占式，按照剩余运行时间的顺序进行调度
    - 当新的作业到达时，比较其运行时间与当前进程的剩余时间，如果其运行时间更少，则挂起当前进程，运行新的进程

2. 交互式系统
    - 交互式系统有大量的用户交互操作，因此该系统的调度算法目标是快速地进行响应

    2.1 时间片轮转

    - 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片；当时间片用完后，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给新的队首进程
    - 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间；而如果时间片过长，那么实时性就不能得到保证

    2.2 优先级调度
    - 为每个进程分配一个优先级，按优先级进行调度
    - 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级

    2.3 多级反馈队列
    - 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次；而多级队列设置了多个队列，每个队列时间片大小都不同，例如 1, 2, 4, 8,..，进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次
    - 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程

3. 实时系统

    - 实时系统要求一个请求在一个确定时间内得到响应
    - 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时
    - 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合

#### 守护进程 daemon thread
- 守护进程是运行在后台的特殊进程，它没有控制终端，一般在系统启动时开始运行，并在系统关闭时被终止
- 守护进程周期性地执行某种任务或者等待处理某些发生的事件，例如管理系统日志的守护进程 syslogd，web 服务 httpd 等
- 守护进程的父进程是 init 进程（Linux 内核启动的第一个用户态），init 进程在 fork 出子进程后就会退出，因此这些守护进程是由 init 继承来的孤儿进程

##### fork 函数
- fork 函数是 Unix 系统下以自身进程创建子进程的系统调用方法，用于拷贝一个与父进程完全相同的子进程
- fork 的实现有两步
    -  复制进程资源，包括进程 pcb，代码段和数据段，用户栈，内核栈，虚拟内存池，页表
    -  执行进程
- 函数原型 pid_t fork();
    - 该进程为父进程时，返回子进程的pid
    - 该进程为子进程时，返回 0
    - fork 执行失败时，返回 -1
- 测试
    ```c++
        int pid = fork();
        if (pid == -1)
            return -1;
        if (pid == 0)
            printf("This is father process with pid %d\n", getpid()      );
        else
            printf("This is child process with pid %d\n", getpid())     ;

    /*
    output
    This is child process with pid 87469
    This is father process with pid 87470
    */
    ```

### 线程

- 线程是 CPU 调度的基本单位
- 一个进程拥有多个线程，线程共享进程的资源
- 线程不拥有资源，但拥有独立的 ID，寄存器组，堆栈，程序计数器
- 同一进程的线程的切换不会引起进程切换，而从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换
- 线程切换时只需保存和设置少量寄存器内容，开销很小
- 线程通信依靠直接读写同一进程中的数据

#### 线程间通信

- 线程间通信的目的主要是用于线程同步，所以像进程通信中的用于数据交换的机制

##### 1. 锁机制

- 互斥锁 mutex
    - 提供以排他方式防止数据结构被并发修改的方法
    - 只有拥有互斥对象的线程才具有访问资源的权限，共享资源不会同时被多个线程所访问
    - C++11 引入了 4 种互斥量：
        - std::mutex：独占互斥量
        - std::timed_mutex：带超时的独占互斥量
        - std::recursive_mutex：递归互斥量
        - std::recursive_timed_mutex：带超时的递归互斥量

- 读写锁 reader-writer lock
    - 用于防止同时有多个写者对共享资源进行写操作
    - 共享资源的访问者被区分为读者和写者，同一时刻只有一个线程获取写锁，但可以有多个线程获取读锁

- 自旋锁 spin lock
    - 自旋锁使用一个死循环反复检查锁变量是否可用
    - 普通的互斥锁在申请不到锁资源时会被操作系统调度进入休眠队列（直到锁的状态改变时被唤醒），并进行上下文切换，但自旋锁在申请不到资源时会执行死循环，使得当前 CPU 占用到达 100%
    - 优点：当需求的锁会在远短于一个时间片的时间内被申请到时，可以直接获取锁资源，避免不必要的上下文切换的开销以提高效率
    - 缺点：会不断地执行死循环，如果需求的锁长时间不能被申请到，会浪费整个时间片的时间

- 条件变量 condition variable
    - 可原子方式阻塞进程，直到某个特定条件为真为止
    - 对条件的测试是在互斥锁的保护下进行的，条件变量始终与互斥锁一起使用
    - C++11 引入的一种用于等待的同步机制，它能阻塞一个或多个线程，直到收到另外一个线程发出的通知或者超时，才会唤醒当前阻塞的线程；条件变量需要和互斥量配合起来用
    - C++11 引入了 2 种条件变量：
        - condition_variable，配合 std::unique_lock<std::mutex> 进行 wait 操作
        - condition_variable_any，和任意带有 lock，unlock 语义的 mutex 搭配使用，比较灵活，但效率比condition_variable差
    - 条件变量的使用过程
        - 拥有条件变量的线程获取互斥量
        - 循环检查某个条件，如果条件不满足，则阻塞直到条件满足；如果条件满足，则向下执行
        - 某个线程满足条件执行完之后调用 notify_one 或 notify_all 唤醒一个或者所有的等待线程

- 原子变量
    - C++11 引入的原子类型 std::atomic\<T\> ，对该变量的操作是原子性，不可中断的

- 临界区
    - 临界区保证在某一时刻只有一个线程能访问区域内的数据
    - 在有一个线程进入临界区后，其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开，其他线程可以继续抢占
    - 只能在同一进程内使用

- Promise

##### 2. 信号量机制

- 无名线程信号量
- 命名线程信号量

##### 3. 信号机制 Signal

- 类似进程间的信号处理
- 事件
    - 事件机制允许一个线程在处理完一个任务后主动唤醒另外一个线程执行任务

##### 4. 屏障 barrier

- 屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行

## 进程和线程对比

1. 进程之间私有和共享的资源
    - 私有：地址空间、堆、全局变量、栈、寄存器
    - 共享：代码段，公共数据，进程目录，进程 ID
2. 线程之间私有和共享的资源
    - 私有：线程栈，寄存器，程序计数器
    - 共享：堆，地址空间，全局变量，静态变量
3. 多进程和多线程

    |对比维度|多进程|多线程|对比|
    |---|---|---|---|
    |数据共享、同步|数据共享复杂，需要用 IPC；数据是分开的，同步简单|因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂|各有应用场景|
    |内存、CPU|占用内存多，切换复杂，CPU 利用率低|占用内存少，切换简单，CPU 利用率高|线程 > 进程|
    |创建销毁、切换|创建销毁、切换复杂，速度慢|创建销毁、切换简单，速度很快|线程 > 进程|
    |编程、调试|编程简单，调试简单|编程复杂，调试复杂|进程 > 线程|
    |可靠性|进程间不会互相影响|一个线程挂掉将导致整个进程挂掉|进程 > 线程|
    |分布式|适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单|适应于多核分布式|进程 > 线程|

4. 对比

    |优劣|多进程|多线程|
    |---|---|---|
    |优点|编程、调试简单，可靠性较高|创建、销毁、切换速度快，内存、资源占用小|
    |缺点|创建、销毁、切换速度慢，内存、资源占用大|编程、调试复杂，可靠性较差|

### 死锁

#### 必要条件

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源

#### 处理方法

1. 鸵鸟策略

    - 把头埋在沙子里，假装根本没发生问题
    - 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能
    - 当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略
    - 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它

2. 死锁检测与死锁恢复

    - 不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复

    1. 每种类型一个资源的死锁检测

        ![Deadlock 1](https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Computer-Science/Deadlock%201.png)

        - 资源分配图中，方框表示资源，圆圈表示进程；资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源；图 a 可以抽取出环如图 b，满足环路等待条件，因此会发生死锁
        - 每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生

    2. 每种类型多个资源的死锁检测

        ![Deadlock 2](https://raw.githubusercontent.com/chr1sc2y/warehouse-deprecated/refs/heads/main/resources/Computer-Science/Deadlock%202.png)

        - 上图中，有三个进程四个资源，E 向量代表资源总量，A 向量代表资源剩余量，C 矩阵代表每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量，R 矩阵代表每个进程请求的资源数量；进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，执行进程 P3，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)；P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1)；P1 也可以执行。所有进程都可以顺利执行，没有死锁
        - 每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程
        - 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A
        - 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1
        - 如果没有这样一个进程，算法终止

    3. 死锁恢复
        - 利用抢占恢复
        - 利用回滚恢复
        - 通过杀死进程恢复

3. 死锁预防

    - 在程序运行之前预防发生死锁

    1. 破坏互斥条件
        - 例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程

    2. 破坏占有和等待条件
        - 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源

    3. 破坏不可抢占条件

    4. 破坏环路等待
        - 给资源统一编号，进程只能按编号顺序来请求资源

4. 死锁避免
    - 在程序运行时避免发生死锁
    1. 安全状态
        - 图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。
        - 定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。
        - 安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比
    2. 单个资源的银行家算法
        - 一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配
        - 上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态
    3. 多个资源的银行家算法
        - 上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。
        - 检查一个状态是否安全的算法如下：
            - 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
            - 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
            - 重复以上两步，直到所有进程都标记为终止，则状态时安全的。
        - 如果一个状态不是安全的，需要拒绝进入这个状态。

## 内存

### 虚拟内存

- 物理内存：主板上的内存条，大小固定；如果程序运行时占用大量的物理内存，就会导致物理内存使用完
- 虚拟内存：在硬盘上划分的一块页面文件；当程序运行时，有一部分资源还没有载入时，系统没必要将程序所有的资源都放在物理内存中，于是系统将这些暂时不用的资源放在虚拟内存上，等待到需要时再载入物理内存
    - 特征
        - 多次性：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性
        - 对换性：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据)
        - 虚拟性：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上

### 地址

- 物理地址（physical address）：内存的实际地址，内存单元的真正地址，与地址总线相对应

- 逻辑地址（logical address）：由 CPU 生成的地址，用于 CPU 内部和编程使用，不唯一；C 语言中取地址操作（&）取得的值就是逻辑地址

- 线性地址（linear address） / 虚拟地址(virtual address)： 跟逻辑地址类似，也是不真实的地址，如果逻辑地址是对应的硬件平台段式管理转换前地址的话，那么线性地址则对应了硬件页式内存的转换前地址

## 缓存

- 命中率：当某个请求能够通过访问缓存而得到响应时，称为缓存命中；缓存命中率越高，缓存利用率越高

- 最大空间：缓存通常位于内存中，内存的空间相对磁盘较小，因此当缓存存放的数据量超过最大空间时，需要淘汰部分数据来存放新到达的数据

### 淘汰策略

- FIFO（First In First Out）：先进先出策略
  - 如果需要经常访问最新的数据，可以使用 FIFO，使得最早到达的数据被淘汰

- LRU（Least Recently Used）：最近最久未使用策略
  - 优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据
  - 保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率

- LFU（Least Frequently Used）：最不经常使用策略
  - 优先淘汰一段时间内使用次数最少的数据

### 内容分发网络 CDN Content distribution network

- 一种互连的网络系统，利用更靠近用户的服务器将静态资源（HTML, CSS, JavaScript）分发给用户

- 优点
  - 更快地将数据分发给用户
  - 通过部署多台服务器，从而提高系统整体的带宽性能
  - 多台服务器可以看成是一种冗余机制，从而具有高可用性

### 缓存问题

- 缓存穿透
    - 对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库
    - 解决方案
        - 对不存在的数据缓存一个空数据
        - 对这类请求进行过滤

- 缓存雪崩
    - 在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求；当由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效，又或者缓存服务器宕机时，数据库会收到大量的请求，导致数据库崩溃
    - 解决方案
        - 防止缓存在同一时间大面积过期：通过观察用户行为，合理设置缓存过期时间来实现
        - 防止缓存服务器宕机：使用分布式缓存；分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用
        - 防止刚上线的系统还未将大量数据进行缓存：进行缓存预热，将相关的缓存数据直接加载到缓存系统

- 缓存一致性
    - 要求数据更新的同时缓存数据也能够实时更新
    - 解决方案
        - 在数据更新的同时立即更新缓存
        - 在读缓存之前先判断缓存是否是最新的，如果不是则先进行更新

- 缓存无底洞
    - 为了满足业务要求添加大量的缓存节点，但性能不但没有好转反而出现了下降
    - 产生原因
        - 缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，key 分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作
        - 批量操作的耗时会随着节点数目的增加而不断增大
        - 网络连接数变多
    - 解决方案
        - 优化批量数据操作命令
        - 减少网络通信次数
        - 降低接入成本，使用长连接/连接池/NIO

## IO

### 同步、异步、阻塞、非阻塞

- 同步与异步是消息通信机制
- 阻塞与非阻塞是程序等待调用结果时的状态

1. 同步
    - 同步是指一个任务需要依赖另外一个任务，只有等待被依赖的任务完成后，依赖的任务才能算完成
    - 当一个同步调用发出后，调用者要一直等待消息结果返回后，才能进行后续的步骤
    - 同步是一种可靠的任务序列，两个任务的状态保持一致（都成功或都失败）

2. 异步
    - 异步是指一个任务不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了
    - 当一个异步调用发出后，调用者不用立刻得到消息结果
    - 异步是一种不可靠的任务序列，被依赖的任务是否完成无法由依赖它的任务是否完成来确定

3. 阻塞
    - 阻塞调用是指在调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回。

4. 非阻塞
    - 非阻塞调用是指在调用结果返回之前，当前线程不会被挂起

### CPU 和 IO 设备交互

- 在 CPU 和外设之间引入了一层 IO 接口，用 IO 接口来匹配 CPU 和外设；
- 为了统一各种不同的 IO 接口，CPU 在南桥中加入了仲裁模块来决定 CPU 访问哪一个 IO 接口
- 对于某一个 IO 接口，通过 IO 接口中的寄存器和 CPU 进行通信，这些寄存器称为端口；当 CPU 想要往端口中写入和读取数据时，可以通过 in 和 out 指令来执行相应的端口号

## 文件

1. 了解inode、权限、用户、时间(ctime/mtime/atime)等文件基本属性   

2. 相关shell命令：
远程文件传输scp/sz/rz...
文件定位find/whereis
lsof
